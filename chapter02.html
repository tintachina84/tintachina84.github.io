<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-06-20T13:56:41.495832"><title>Chapter 2 - Spring Framework 기초 | Infosiatec Workshop</title><script type="application/json" id="virtual-toc-data">[{"id":"2-1","level":0,"title":"2.1 스프링 프레임워크의 패턴과 패러다임 이해하기","anchor":"#2-1"},{"id":"2-2-ioc","level":0,"title":"2.2 IoC 컨테이너의 이해","anchor":"#2-2-ioc"},{"id":"di-dependency-injection_1","level":0,"title":"2.3 DI(Dependency Injection)를 하는 방법","anchor":"#di-dependency-injection_1"},{"id":"2-4","level":0,"title":"2.4 애너테이션을 사용한 스프링 빈의 메타데이터 구성하기","anchor":"#2-4"},{"id":"2-5-aop","level":0,"title":"2.5 AOP 코드 작성해보기","anchor":"#2-5-aop"},{"id":"2-6","level":0,"title":"2.6 스프링 부트는 왜 사용하나요?","anchor":"#2-6"},{"id":"2-7","level":0,"title":"2.7 서블릿 디스패처의 중요성을 이해하기","anchor":"#2-7"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b267/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Chapter 2 - Spring Framework 기초 | Infosiatec Workshop"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Infosiatec Workshop Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/chapter02.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Chapter 2 - Spring Framework 기초 | Infosiatec Workshop"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/chapter02.html#webpage",
    "url": "writerside-documentation/chapter02.html",
    "name": "Chapter 2 - Spring Framework 기초 | Infosiatec Workshop",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Infosiatec Workshop Help"
}</script><!-- End Schema.org --></head><body data-id="Chapter02" data-main-title="Chapter 2 - Spring Framework 기초" data-article-props="{&quot;seeAlso&quot;:[{&quot;title&quot;:&quot;참고문헌&quot;,&quot;links&quot;:[{&quot;url&quot;:&quot;https://martinfowler.com/articles/injection.html&quot;,&quot;text&quot;:&quot;IoC 컨테이너와 DI 패턴&quot;},{&quot;url&quot;:&quot;https://docs.spring.io/spring-framework/reference/&quot;,&quot;text&quot;:&quot;Spring Framework Documentation&quot;}]}],&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs=""><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Infosiatec Workshop  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Chapter02" id="Chapter02.md">Chapter 2 - Spring Framework 기초</h1><section class="chapter"><h2 id="2-1" data-toc="2-1">2.1 스프링 프레임워크의 패턴과 패러다임 이해하기</h2><p id="gvfcj0_2">Spring은 Java 언어로 작성된 프레임워크입니다. Spring Data, Spring Security, Spring Cloud, Spring Web 등 다양한 모듈을 제공합니다. 기업용 애플리케이션을 구축하는 데 인기가 있습니다. 처음에는 Java Enterprise Edition (Java EE) 대안 정도로 여겨졌지만, 시간이 지남에 따라 Java EE보다 선호되는 프레임워크가 되었습니다. Spring은 핵심적으로 의존성 주입(DI), 제어의 역전(IoC)으로 알려진 기능과 관점 지향 프로그래밍(AOP)을 지원합니다. Java 외에도 Spring은 Groovy와 Kotlin과 같은 다른 JVM 언어를 지원합니다.</p><section class="chapter"><h3 id="ioc-inversion-of-control" data-toc="ioc-inversion-of-control">IoC(Inversion of Control)는 무엇인가요?</h3><ul class="list _bullet" id="gvfcj0_3"><li class="list__item" id="gvfcj0_4"><p>절차적 프로그래밍 - 프로그램이 작성된 순서대로 실행되는 방식</p></li><li class="list__item" id="gvfcj0_5"><p>객체지향 프로그래밍 - 객체를 생성하고 객체 간의 관계를 정의하는 방식</p></li></ul><p id="gvfcj0_6">전통적인 CLI 프로그램은 절차적 프로그래밍의 전형적인 방법이며, 흐름은 프로그래머에 의해 결정되며 코드가 순차적으로 실행되어 한 조각씩 실행됩니다. <br> 그러나 UI 기반 OS 애플리케이션은 사용자 입력과 이벤트에 따라 프로그램의 흐름을 결정하며 동적입니다.</p><p id="gvfcj0_8">옛날, 대부분의 절차적 프로그래밍 방식이 주를 이룰 때에는 프로그래머가 흐름을 지배하는 전통적인 절차적 방식에서 흐름 제어를 프레임워크나 컴포넌트와 같은 외부 소스로 옮길 방법을 찾아야 했습니다. 이러한 움직임이 바로 IoC라고 불리는 것입니다.</p><p id="gvfcj0_9">객체 지향 프로그래밍(OOP) 접근 방식이 도입되면서, 프레임워크는 빠르게 DI를 지원하는 IoC 컨테이너 패턴 구현을 제공하기 시작했습니다.</p><p id="gvfcj0_10"><a href="http://www.laputan.org/drc/drc.html" id="gvfcj0_11" data-external="true" rel="noopener noreferrer">Designing Reusable Classes</a><br><a href="https://folk.universitetetioslo.no/trygver/themes/mvc/mvc-index.html" id="gvfcj0_13" data-external="true" rel="noopener noreferrer">MVC</a></p></section><section class="chapter"><h3 id="di-dependency-injection" data-toc="di-dependency-injection">DI(Dependency Injection)는 무엇인가요?</h3><p id="gvfcj0_14">프로그램을 작성해야 하는데 데이터베이스에서 일부 데이터를 가져와야 한다고 가정해 봅시다. 따라서 프로그램에는 데이터베이스 연결이 필요합니다. JDBC 데이터베이스 연결 객체를 사용할 수 있으며, 프로그램에서 데이터베이스 연결 객체를 즉시 인스턴스화하고 할당할 수 있습니다.</p><p id="gvfcj0_15">또는 JDBC 데이터베이스 연결 객체를 생성자 또는 setter 메서드 파라미터로 사용할 수 있습니다. 그러면 프레임워크가 구성에 따라 연결 객체를 생성하고 그 객체를 런타임에 프로그램에 할당합니다. 여기서 프레임워크는 <span id="gvfcj0_16"><b><i><font style="color:#bc8f8f">런타임에 연결 객체를 주입</font></i></b></span>합니다. 이를 DI라고 합니다. Spring은 클래스 구성을 위해 DI를 지원합니다.</p><p id="gvfcj0_17">DI는 IoC의 한 유형입니다. IoC 컨테이너는 구현 객체를 구성하고 유지합니다. 다른 객체에 필요한 객체(의존성의 한 형태)는 생성자, 설정자 또는 인터페이스를 통해 필요한 객체에 주입됩니다. 이는 인스턴스화를 분리하고 실행 시 DI를 가능하게 합니다.</p><ul class="list _bullet" id="gvfcj0_18"><li class="list__item" id="gvfcj0_19"><p>강한 결합을 하는 코드 </p><figure id="gvfcj0_20"><img alt="coupling_1.png" src="images/coupling_1.png" title="coupling_1.png" width="998" height="196"></figure></li></ul><div class="code-collapse" data-lang="java" data-is-expanded="false" data-synopsis="public class SwitchButton {">
    public class SwitchButton {

    Lamp lamp = new Lamp();
    boolean isOn = false;

    public void press() {
        if (isOn) {
            lamp.turnOff();
            isOn = false;
        } else {
            lamp.turnOn();
            isOn = true;
        }
    }
}

public class Lamp {
    public void turnOn() {
        System.out.println(&quot;Lamp On&quot;);
    }

    public void turnOff() {
        System.out.println(&quot;Lamp Off&quot;);
    }
}

</div><ul class="list _bullet" id="gvfcj0_23"><li class="list__item" id="gvfcj0_24"><p>느슨한 결합을 하는 코드 </p><figure id="gvfcj0_25"><img alt="coupling_2.png" src="images/coupling_2.png" title="coupling_2.png" width="1280" height="177"></figure></li></ul><div class="code-collapse" data-lang="java" data-is-expanded="false" data-synopsis="public class SwitchButton {">
    public class SwitchButton {

    Switchable lamp = new Lamp();
    boolean isOn = false;

    public void press() {
        if (isOn) {
            lamp.turnOff();
            isOn = false;
        } else {
            lamp.turnOn();
            isOn = true;
        }
    }
}

interface Switchable {
    void turnOn();
    void turnOff();
}

public class Lamp implements Switchable {
    public void turnOn() {
        System.out.println(&quot;Lamp On&quot;);
    }

    public void turnOff() {
        System.out.println(&quot;Lamp Off&quot;);
    }
}

</div></section><section class="chapter"><h3 id="aop-aspect-oriented-programming" data-toc="aop-aspect-oriented-programming">AOP(Aspect-Oriented Programming)는 무엇인가요?</h3><p id="gvfcj0_28">AOP는 OOP와 함께하는 프로그래밍 패러다임입니다. OOP에서는 특정 클래스에서 단일 책임만을 처리하는 것이 좋은 실천 방법입니다. 이 원칙을 단일 책임 원칙(SRP)이라고 하며, 모듈/클래스/메소드에 적용됩니다.</p><p id="gvfcj0_29">예를 들어, 자동차 도메인 애플리케이션에서 Gear 클래스는 기어 객체와 관련된 기능만 허용하고 브레이킹과 같은 다른 기능을 수행하지 않아야 합니다. 그러나 프로그래밍 모델에서는 종종 여러 클래스에 걸쳐 확장되는 기능이나 함수가 필요합니다.</p><p id="gvfcj0_30">로그 기록, 보안, 트랜잭션 관리 및 메트릭과 같은 기능은 여러 클래스/모듈에서 필요합니다. 이러한 기능의 코드는 여러 클래스에 흩어져 있습니다. 이러한 기능은 객체 모델의 여러 지점에 걸쳐있는 교차 관심사입니다. AOP는 여러 클래스/모듈에서 이러한 측면을 처리할 수 있는 방법을 제공합니다.</p><p id="gvfcj0_31">AOP를 구현하는 방법에는 여러가지가 있지만 스프링 프레임워크에서는 프록시 패턴을 사용하여 AOP를 구현합니다.</p><section class="chapter"><h4 id="gvfcj0_32" data-toc="gvfcj0_32">주요 키워드</h4><ul class="list _bullet" id="gvfcj0_33"><li class="list__item" id="gvfcj0_34"><p>Aspect - 모듈화된 관심사</p></li><li class="list__item" id="gvfcj0_35"><p>Join Point - 코드 실행 중의 특정 지점</p></li><li class="list__item" id="gvfcj0_36"><p>Advice - 결합점에서 실행되는 코드</p></li><li class="list__item" id="gvfcj0_37"><p>Pointcut - 결합점의 집합</p></li><li class="list__item" id="gvfcj0_38"><p>Proxy - 대상 객체를 감싸는 객체</p></li><li class="list__item" id="gvfcj0_39"><p>Target - 프록시가 감싸는 객체 (Class, Method...)</p></li></ul></section></section></section><section class="chapter"><h2 id="2-2-ioc" data-toc="2-2-ioc">2.2 IoC 컨테이너의 이해</h2><p id="gvfcj0_40"><code class="code" id="gvfcj0_41">BeanFactory (org.springframework.beans.factory.BeanFactory)</code> 및 <code class="code" id="gvfcj0_42">ApplicationContext (org.springframework.context.ApplicationContext)</code>는 IoC 컨테이너의 기초를 제공하는 두 가지 중요한 인터페이스입니다.</p><ul class="list _bullet" id="gvfcj0_43"><li class="list__item" id="gvfcj0_44"><p>BeanFactory - IoC 컨테이너의 최상위 인터페이스로, 빈을 관리하고 검색하는 기능을 제공합니다.</p></li><li class="list__item" id="gvfcj0_45"><p>ApplicationContext - BeanFactory 인터페이스를 확장하며, 메시지 처리, 이벤트 게시, 애플리케이션 레벨의 리소스 로딩 등의 기능을 제공합니다.</p></li></ul><p id="gvfcj0_46">이제 ApplicationContext 인터페이스가 IoC 컨테이너를 나타내고 빈을 관리한다는 것을 알았을 것입니다. 그러나 빈을 어떻게 인스턴스화, 조립 및 설정할지 궁금하죠? 어디에서 지시를 받을까요? 답은 Configuration 메타데이터입니다. Configuration 메타데이터를 통해 응용 프로그램 객체와 해당 객체들 간의 상호 의존성을 표현할 수 있습니다. 구성 메타데이터는 세 가지 방법으로 표현할 수 있습니다: XML 구성, Java 어노테이션 및 Java 코드. 비즈니스 객체를 작성하고 구성 메타데이터를 제공하면 Spring 컨테이너가 그림에 나와 있는 것처럼 완전히 구성된 사용 준비 시스템을 생성합니다.</p><figure id="gvfcj0_47"><img alt="spring_config.png" src="images/spring_config.png" title="spring_config.png" width="1650" height="663"></figure><section class="chapter"><h3 id="gvfcj0_48" data-toc="gvfcj0_48">스프링 빈 만들기</h3><p id="gvfcj0_49">빈(Bean)은 IoC 컨테이너에 의해 관리되는 Java 객체입니다. 개발자는 IoC 컨테이너에 구성 메타데이터를 제공하고, 컨테이너는 해당 메타데이터를 사용하여 빈을 구성, 조립 및 관리합니다.</p><div class="code-collapse" data-lang="java" data-is-expanded="false" data-synopsis="public class SampleBean {">
    public class SampleBean {

    public void init() {
        // bean code
    }

    public void destroy() {
        // bean code
    }
}

public interface BeanInterface {
    // interface code
}

public class BeanInterfaceImpl implements BeanInterface {
    // bean code
}

@Configuration
public class AppConfig {
    @Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;, name = {&quot;sampleBean&quot;, &quot;sb&quot;})
    @Description(&quot;Demonstrate a simple bean&quot;)
    public SampleBean sampleBean() {
        return new SampleBean();
    }

    @Bean
    public BeanInterface beanInterface() {
        return new BeanInterfaceImpl();
    }
}

</div><p id="gvfcj0_52">위 코드에서 빈은 AppConfig 클래스를 사용하여 선언됩니다. @Configuration은 클래스 레벨의 애너테이션으로, 해당 클래스에 구성 코드가 포함되어 있음을 나타냅니다. @Bean은 빈을 정의하는 데 사용되는 메서드 레벨의 애너테이션입니다. 또한 코드에서 보여지는 대로 @Bean 애너테이션 속성을 사용하여 빈의 초기화 및 소멸 라이프 사이클 메서드를 전달할 수도 있습니다.</p><p id="gvfcj0_53">일반적으로 빈의 이름은 첫 글자를 소문자로 한 클래스 이름입니다. 예를 들어 BeanInterface의 빈 이름은 beanInterface가 됩니다. name 속성을 사용하여 빈 이름과 별칭을 정의할 수도 있습니다.</p><p id="gvfcj0_54">@Bean(Method 레벨) 애너테이션은 @Component(Class 레벨) 애너테이션의 내부에 있어야 합니다. @Component 애너테이션은 스프링 빈을 선언하는 일반적인 방법입니다.</p><p id="gvfcj0_55">애플리케이션 컨텍스트에 등록된 스프링 빈은 기본적으로 싱글턴으로 관리됩니다. 즉, 스프링에 여러 번 빈을 요청하더라도 언제나 같은 인스턴스가 반환됩니다. 이는 스프링이 대규모 트래픽을 처리할 수 있게 하기 위함입니다. 스프링은 최초 설계때부터 대규모 엔터프라이즈 환경을 상정해 요청을 처리할 수 있도록 고안되었습니다. 매번 클라이언트에서 요청이 올 때 마다 new Service()와 같은 코드를 사용하여 새로운 인스턴스를 생성하는 것은 비효율적입니다.</p><div class="code-collapse" data-lang="java" data-is-expanded="false" data-synopsis="@Component">
    @Component
    public class Foo {
        @Bean
        public SampleBean sampleBean() {
            return new SampleBean();
        }
    }
</div><p id="gvfcj0_57">@Configuration, @Controller, @Service, @Repository 등의 애너테이션들도 실은 @Component 애너테이션을 확장한 것입니다.</p></section><section class="chapter"><h3 id="componentscan" data-toc="componentscan">@ComponentScan 애너테이션</h3><div class="code-collapse" data-lang="java" data-is-expanded="false" data-synopsis="@Configuration">
    @Configuration
    @ComponentScans({
        @ComponentScan(basePackages = &quot;com.example&quot;),
        @ComponentScan(basePackageClasses = {Foo.class, Bar.class})
    })
    public class AppConfig {
        // bean definitions
    }
</div></section></section><section class="chapter"><h2 id="di-dependency-injection_1" data-toc="di-dependency-injection_1">2.3 DI(Dependency Injection)를 하는 방법</h2><section class="chapter"><h3 id="gvfcj0_59" data-toc="gvfcj0_59">일반적인 인스턴스 생성</h3><div class="code-block" data-lang="java">
    public class CartService {

    private CartRepository cartRepository;

    public CartService() {
        this.cartRepository = new CartRepository();
    }
}

</div></section><section class="chapter"><h3 id="gvfcj0_62" data-toc="gvfcj0_62">생성자 주입</h3><div class="code-block" data-lang="java">
    public class CartService {

    private CartRepository cartRepository;

    public CartService(CartRepository cartRepository) {
        this.cartRepository = cartRepository;
    }
}

</div></section><section class="chapter"><h3 id="gvfcj0_65" data-toc="gvfcj0_65">생성자를 사용하여 의존성 정의하기</h3><div class="code-block" data-lang="java">
    @Configuration
    public class AppConfig {
        @Bean
        public CartRepository cartRepository() {
            return new CartRepositoryImpl();
        }
        @Bean
        public CartService cartService() {
            return new CartService(cartRepository());
        }
    }
</div></section><section class="chapter"><h3 id="setter" data-toc="setter">Setter를 통한 주입</h3><div class="code-block" data-lang="java">
    @Configuration
    public class AppConfig {
        @Bean
        public CartRepository cartRepository() {
            return new CartRepositoryImpl();
        }
        @Bean
        public CartService cartService() {
            CartService service = new CartService();
            Service.setCartService(cartRepository());
            return service;
        }
    }
</div></section><section class="chapter"><h3 id="autowired" data-toc="autowired">@Autowired 애너테이션을 사용한 의존성 주입</h3><div class="code-block" data-lang="java">
    public class CartService {
        @Autowired
        private CartRepository cartRepository;
    }
</div></section></section><section class="chapter"><h2 id="2-4" data-toc="2-4">2.4 애너테이션을 사용한 스프링 빈의 메타데이터 구성하기</h2><section class="chapter"><h3 id="autowired_1" data-toc="autowired_1">@Autowired는 어떻게 사용하나요?</h3><p id="gvfcj0_69">@Autowired 애너테이션을 사용하면 @Configuration으로 별도의 구성 클래스를 작성하는 대신 빈의 클래스 내에서 의존성을 주입할 수 있습니다.</p><div class="code-block" data-lang="java">

@Component
public class CartService {
    private CartRepository repository;
    private ARepository aRepository;
    private BRepository bRepository;
    private CRepository cRepository;

    @Autowired // 멤버변수 기반
    private AnyBean anyBean;

    @Autowired // 생성자 기반
    public CartService(CartRepository repository) {
        this.repository = repository;
    }

    @Autowired // Setter 기반
    public void setARepository(ARepository aRepo) {
        this.aRepository = aRepo;
    }

    @Autowired // 메서드 기반
    public void xMethod(BRepository bRepo, CRepository cRepo) {
        this.bRepository = bRepo;
        this.cRepository = cRepo;
    }
}

</div></section><section class="chapter"><h3 id="qualifier" data-toc="qualifier">@Qualifier 애너테이션을 사용한 매칭</h3><p id="gvfcj0_72">아래의 코드를 실행하면 NoUniqueBeanDefinitionException이 발생합니다.</p><div class="code-block" data-lang="java">

@Configuration
public class AppConfig {
    @Bean
    public CartService cartService1() {
      return new CartServiceImpl1();
    }

    @Bean
    public CartService cartService2() {
      return new CartServiceImpl2();
    }
}

@Controller
public class CartController {
    @Autowired
    private CartService service1;

    @Autowired
    private CartService service2;
}

</div><p id="gvfcj0_75">이럴 때 @Qualifier 애너테이션을 사용하여 매칭시킬 수 있습니다.</p><div class="code-block" data-lang="java">

@Controller
public class CartController {
    @Autowired
    @Qualifier(&quot;cartService1&quot;)
    private CartService service1;

    @Autowired
    @Qualifier(&quot;cartService2&quot;)
    private CartService service2;
}

</div></section></section><section class="chapter"><h2 id="2-5-aop" data-toc="2-5-aop">2.5 AOP 코드 작성해보기</h2><p id="gvfcj0_78">앞서 스프링의 패턴과 패러다임 이해하기 섹션에서 AOP에 대해 설명했습니다. 간단히 말해서, AOP는 로깅, 트랜잭션, 보안과 같은 교차적인 문제를 해결하는 프로그래밍 패러다임입니다.</p><p id="gvfcj0_79">다음 코드는 메서드가 실행하는데 걸리는 시간을 측정합니다.</p><div class="code-block" data-lang="java">

public class Test {
    void performSomeTask() {
        long start = System.currentTimeMillis();
        // Business Logic
        long executionTime = System.currentTimeMillis() - start;
        System.out.println(&quot;Time taken: &quot; + executionTime + &quot;ms&quot;);
    }
}

</div><p id="gvfcj0_82">애플리케이션에 수백 개의 메서드가 있는 경우 각 메서드에 시간 캡처 코드를 추가하여 실행에 걸리는 시간을 모니터링해야 합니다. 하지만 나중에 시간 캡처 코드를 수정하려면 어떻게 해야 할까요? 모든 위치에서 코드를 수정해야 할 것입니다. 이때 AOP가 도움이 됩니다. 크로스 컷팅(Cross-Cutting) 코드를 모듈화할 수 있습니다.</p><figure id="gvfcj0_83"><img alt="aop.png" src="images/aop.png" title="aop.png" width="486" height="320"></figure><p id="gvfcj0_84">메서드가 실행되는 데 걸리는 시간을 캡처하는 AOP 예제를 만들어 보겠습니다. 여기서 모니터링 시간 로깅은 메서드가 실행되는 데 걸리는 시간을 캡처하는 애스팩트가 될 것입니다.</p><p id="gvfcj0_85">첫 번째 단계로 메서드를 대상으로 하는 애너테이션(TimeMonitor)을 정의합니다. TimeMonitor로 애너테이션된 메서드는 해당 메서드에 걸린 시간을 기록합니다. 이렇게 하면 포인트컷(결합점)을 식별하는 데 도움이 됩니다.</p><div class="code-block" data-lang="java">

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface TimeMonitor {}

</div><p id="gvfcj0_88">@Aspect 어노테이션은 클래스를 애스펙트로 표시하는 데 사용됩니다.</p><div class="code-block" data-lang="java">

@Aspect
@Component
public class TimeMonitorAspect {
    @Around(&quot;@annotation(TimeMonitor)&quot;) // 애너테이션을 사용하여 포인트컷을 식별
    public Object logTime(ProceedingJoinPoint joinPoint) throws Throwable {
        long start = System.nanoTime();
        Object proceed = joinPoint.proceed();
        long exeTime = System.nanoTime() - start;
        System.out.println(joinPoint.getSignature().getName() + &quot; took: &quot; + exeTime + &quot; ns&quot;);

        return proceed;
    }
}

</div><div class="table-wrapper"><table class="wide" id="gvfcj0_91"><thead><tr class="ijRowHead" id="gvfcj0_92"><th id="gvfcj0_93"><p>애너테이션 종류</p></th><th id="gvfcj0_94"><p>역할</p></th></tr></thead><tbody><tr id="gvfcj0_95"><td id="gvfcj0_96"><p>@Before</p></td><td id="gvfcj0_97"><p>Advice가 JoinPoint 이전에 실행됨</p></td></tr><tr id="gvfcj0_98"><td id="gvfcj0_99"><p>@After</p></td><td id="gvfcj0_100"><p>메서드의 결과(셩공, 실패)에 관계없이 Advice가 JoinPoint 이후에 실행됨</p></td></tr><tr id="gvfcj0_101"><td id="gvfcj0_102"><p>@AfterReturning</p></td><td id="gvfcj0_103"><p>JoinPoint가 성공적으로 실행된 후 Advice가 실행됨</p></td></tr><tr id="gvfcj0_104"><td id="gvfcj0_105"><p>@AfterThrowing</p></td><td id="gvfcj0_106"><p>JoinPoint가 예외를 던진 후 Advice가 실행됨</p></td></tr><tr id="gvfcj0_107"><td id="gvfcj0_108"><p>@Around</p></td><td id="gvfcj0_109"><p>JoinPoint의 전후로 Advice가 실행됨</p></td></tr></tbody></table></div><p id="gvfcj0_110">어떻게 이것이 가능한지 궁금하지 않으세요? 이것은 스프링 AOP가 프록시를 사용하여 구현되기 때문입니다. 스프링은 프록시를 사용하여 애스팩트를 적용하고, 프록시는 대상 객체의 메서드 호출을 가로채서 애스팩트를 적용합니다. Spring Boot에서는 CGLIB(Code Generator Library) 라이브러리를 사용하여 프록시를 생성합니다. <a href="https://huisam.tistory.com/entry/springAOP" id="gvfcj0_111" data-external="true" rel="noopener noreferrer">Spring AOP와 프록시</a></p></section><section class="chapter"><h2 id="2-6" data-toc="2-6">2.6 스프링 부트는 왜 사용하나요?</h2><p id="gvfcj0_112">요즘에는 Spring Boot가 최신 기술을 활용한 제품 수준의 Spring 특화 웹 애플리케이션을 개발하는 명백한 선택지입니다. <br><a href="https://projects.spring.io/spring-boot/" id="gvfcj0_114" data-external="true" rel="noopener noreferrer">스프링 공식 사이트</a></p><p id="gvfcj0_115">오늘날의 클라우드 환경은 플랫폼 서비스(PaaS) 제공으로 대부분의 기능을 제공하며 신뢰성, 관리 및 확장과 같은 컨테이너 기반 웹 아키텍처에서 제공하는 대부분의 기능을 제공하고 있습니다. 따라서 Spring Boot는 자신을 초경량 컨테이너로 만드는 데 초점을 맞추고 있습니다.</p><p id="gvfcj0_116">Spring Boot는 자체 기본 구성을 갖고 있으며 프로덕션에 준비된 웹 애플리케이션 개발을 간단하게 만들기 위해 자동 구성도 지원합니다. Spring Initializr(http://start.spring.io)는 Maven 또는 Gradle과 같은 빌드 도구와 프로젝트 메타데이터(그룹, 아티팩트 및 종속성)를 간단히 선택하는 웹 기반 서비스입니다. 필수 필드를 작성한 후 Generate Project 버튼을 클릭하면 프로덕션 애플리케이션에 사용할 수 있는 Spring Boot 프로젝트가 제공됩니다.</p><p id="gvfcj0_117">간단히 말해서, Spring Initializr는 모든 구성을 대신 처리해주어 우리가 비즈니스 로직과 API 작성에 집중할 수 있도록 도와줍니다.</p></section><section class="chapter"><h2 id="2-7" data-toc="2-7">2.7 서블릿 디스패처의 중요성을 이해하기</h2><p id="gvfcj0_118">이전 장에서 RESTful 웹 서비스가 HTTP 프로토콜 위에서 개발된다는 것을 배웠습니다. 자바에는 HTTP와 작업할 수 있는 서블릿 기능이 있습니다. 서블릿을 사용하면 REST 엔드포인트에서 작동할 수 있는 경로 매핑을 할 수 있고 식별을 위한 HTTP 메소드를 제공합니다. 또한 서블릿을 사용하면 JSON 및 XML을 포함한 다양한 유형의 응답 객체를 형성할 수 있습니다. 그러나 서블릿은 개발자가 직접 요청 URI를 처리하고 매개변수를 구문 분석하며 JSON/XML을 변환하고 응답을 처리해야 하는 다소 조잡한 REST 엔드포인트를 구현하는 방법을 제공하고 있습니다.</p><p id="gvfcj0_119">Spring MVC는 이를 해결하기 위한 대안입니다. 이 MVC 패턴은 스프링 프레임워크의 첫 릴리스부터 함께 해왔습니다.</p><ul class="list _bullet" id="gvfcj0_120"><li class="list__item" id="gvfcj0_121"><p>Model: 델은 애플리케이션 데이터를 포함하는 Java 객체(POJO)입니다. 또한 애플리케이션의 상태를 나타냅니다.</p></li><li class="list__item" id="gvfcj0_122"><p>View: 뷰는 HTML/JSP/템플릿 파일로 구성된 프레젠테이션 계층입니다. 뷰는 모델에서 데이터를 렌더링하고 HTML 출력물을 생성합니다.</p></li><li class="list__item" id="gvfcj0_123"><p>Controller: 컨트롤러는 사용자 요청을 처리하고 모델을 구축합니다.</p></li></ul><figure id="gvfcj0_124"><img alt="servlet_1.png" src="images/servlet_1.png" title="servlet_1.png" width="381" height="273"></figure><p id="gvfcj0_125"><span class="control" id="gvfcj0_126">DispatcherServlet</span>은 Spring MVC의 일부입니다. 이는 프론트 컨트롤러로 작동하여 모든 들어오는 HTTP 요청을 처리합니다. Spring MVC는 UI 앱이 백엔드의 일부인 전통적인 웹 애플리케이션을 개발할 수 있게 해주는 웹 프레임워크입니다. 그러나 RESTful 웹 서비스를 개발하고 UI는 React를 기반으로 할 것이므로, 서블릿 디스패처 역할은 <span class="control" id="gvfcj0_127">@RestController</span>를 사용하여 REST 엔드포인트를 구현하는 데에만 제한될 것입니다.</p><figure id="gvfcj0_128"><img alt="servlet_3.png" src="images/servlet_3.png" title="servlet_3.png" width="1417" height="543"></figure><ol class="list _decimal" id="gvfcj0_129" type="1"><li class="list__item" id="gvfcj0_130"><p>사용자가 HTTP 요청을 보내면 DispatcherServlet이 받습니다.</p></li><li class="list__item" id="gvfcj0_131"><p>DispatcherServlet은 HandlerMapping에 바톤을 넘깁니다. HandlerMapping은 요청된 URI에 대한 올바른 컨트롤러를 찾아 DispatcherServlet에 다시 전달합니다.</p></li><li class="list__item" id="gvfcj0_132"><p>그 후 DispatcherServlet은 HandlerAdapter를 사용하여 Controller를 처리합니다.</p></li><li class="list__item" id="gvfcj0_133"><p>HandlerAdapter는 Controller 내부에서 적절한 메소드를 호출합니다.</p></li><li class="list__item" id="gvfcj0_134"><p>컨트롤러는 연관된 비즈니스 로직을 실행하고 응답을 만듭니다.</p></li><li class="list__item" id="gvfcj0_135"><p>Spring은 Java에서 JSON/XML 변환을 위해 요청 및 응답 객체의 marshaling/unmarshalling을 활용합니다.</p></li></ol><p id="gvfcj0_136">다음 장에서는 OpenAPI 명세서를 사용하여 첫 번째 REST API 애플리케이션을 구현하고 Spring 컨트롤러를 사용하여 구현할 것입니다.</p></section><div class="last-modified">Last modified: 20 6월 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="chapter01.html" class="navigation-links__prev">Chapter 1 - RestFul 웹서비스 기초</a><a href="chapter03.html" class="navigation-links__next">Chapter 3 - API 명세 및 구현</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b267/app.js"></script></body></html>