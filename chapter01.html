<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-06-20T13:56:41.496926"><title>Chapter 1 - RestFul 웹서비스 기초 | Infosiatec Workshop</title><script type="application/json" id="virtual-toc-data">[{"id":"1-1-rest-api","level":0,"title":"1.1 REST API 소개","anchor":"#1-1-rest-api"},{"id":"1-2-rest","level":0,"title":"1.2 REST 기본 사항","anchor":"#1-2-rest"},{"id":"1-3-http","level":0,"title":"1.3 HTTP 메서드 및 상태 코드","anchor":"#1-3-http"},{"id":"http_status_codes","level":0,"title":"1.4 HTTP 상태 코드","anchor":"#http_status_codes"},{"id":"1-5-hateoas-hypermedia-as-the-engine-of-application-state","level":0,"title":"1.5 HATEOAS(Hypermedia As The Engine Of Application State)","anchor":"#1-5-hateoas-hypermedia-as-the-engine-of-application-state"},{"id":"rest-api_1","level":0,"title":"1.6 REST API를 설계하는 방법","anchor":"#rest-api_1"},{"id":"1-7-e","level":0,"title":"1.7 e-커머스 앱 개요","anchor":"#1-7-e"},{"id":"1-8","level":0,"title":"1.8 복습","anchor":"#1-8"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b267/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Chapter 1 - RestFul 웹서비스 기초 | Infosiatec Workshop"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Infosiatec Workshop Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/chapter01.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Chapter 1 - RestFul 웹서비스 기초 | Infosiatec Workshop"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/chapter01.html#webpage",
    "url": "writerside-documentation/chapter01.html",
    "name": "Chapter 1 - RestFul 웹서비스 기초 | Infosiatec Workshop",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Infosiatec Workshop Help"
}</script><!-- End Schema.org --></head><body data-id="Chapter01" data-main-title="Chapter 1 - RestFul 웹서비스 기초" data-article-props="{&quot;seeAlso&quot;:[{&quot;title&quot;:&quot;참고문헌&quot;,&quot;links&quot;:[{&quot;url&quot;:&quot;https://ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;,&quot;text&quot;:&quot;REST 최초 제안 논문(Roy Fielding)&quot;}]}],&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs=""><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Infosiatec Workshop  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Chapter01" id="Chapter01.md">Chapter 1 - RestFul 웹서비스 기초</h1><p id="-yqze6v_2">이 장에서는 RESTful API(또는 줄여서 REST API)의 기본 사항과 해당 디자인 패러다임을 살펴보겠습니다. HATEOAS(Hypermedia As The Engine Of Application State)를 살펴보기 전에 REST의 역사를 간략하게 살펴보고, 리소스가 어떻게 형성되는지 알아보고, 메서드와 상태 코드를 이해하겠습니다. 이러한 기본 사항은 RESTful 웹 서비스를 개발할 수 있는 견고한 플랫폼을 제공해야 합니다. 또한 API(애플리케이션 프로그래밍 인터페이스) 설계에 대한 모범 사례도 배우게 됩니다.</p><ul class="list _bullet" id="-yqze6v_3"><li class="list__item" id="-yqze6v_4"><p>REST API 소개</p></li><li class="list__item" id="-yqze6v_5"><p>리소스 및 URI(Uniform Resource Identifier) 처리</p></li><li class="list__item" id="-yqze6v_6"><p>HTTP(Hypertext Transfer Protocol) 메서드 및 상태 코드 탐색</p></li><li class="list__item" id="-yqze6v_7"><p>HATEOAS란 무엇인가요?</p></li><li class="list__item" id="-yqze6v_8"><p>REST API 설계 모범 사례</p></li><li class="list__item" id="-yqze6v_9"><p>전자상거래 앱 개요(샘플 앱)</p></li></ul><section class="chapter"><h2 id="1-1-rest-api" data-toc="1-1-rest-api">1.1 REST API 소개</h2><p id="-yqze6v_10">API는 코드 조각이 다른 코드 조각과 통신하는 방식입니다. 예를 들어 Java는 컬렉션, 입력/출력 및 스트림과 같은 다양한 모듈에 래핑된 클래스를 통해 API를 제공합니다. <br> SDK API를 사용하면 프로그램의 한 부분이 프로그램의 다른 부분과 통신할 수 있습니다. 함수를 작성한 다음 다른 클래스에서 사용할 수 있도록 <kbd class="keystroke" id="-yqze6v_12" data-bypass="true"><span class="keystroke__value">Public</span></kbd> 접근자를 사용하여 노출할 수 있습니다. 그러나 이러한 클래스나 라이브러리를 사용하여 노출되는 API는 단일 애플리케이션 또는 개별 서비스 내부의 내부 통신만 허용합니다. 그렇다면 두 개 이상의 애플리케이션(또는 서비스)이 서로 통신하려는 경우, 즉 두 개 이상의 서비스를 통합하려는 경우 어떻게 될까요? <br> 역사적으로 한 애플리케이션을 다른 애플리케이션과 통합하는 방법에는 RPC, SOAP(Simple Object Access Protocol) 기반 서비스 등 다양한 방법이 있었습니다. 앱 통합은 특히 클라우드와 휴대폰의 붐 이후 소프트웨어 아키텍처의 필수적인 부분이 되었습니다. 현재는 REST가 가장 널리 사용되고 있으며 통합 및 웹 앱 소비를 위한 API 작성의 표준이 되었습니다. REST는 REpresentational State Transfer의 약자로 소프트웨어 아키텍처 스타일입니다.</p><p id="-yqze6v_14">REST의 아키텍처 스타일을 통해 모든 서버는 네트워크를 통해 다른 서버와 통신할 수 있습니다. 이는 의사소통을 단순화하고 통합을 더 쉽게 만들었습니다. REST는 HTTP 위에서 작동하도록 만들어졌으므로 웹 전체와 내부 네트워크에서 사용할 수 있습니다. <br> eBay는 REST 기반 API를 최초로 활용했습니다. 2000년 11월 선정된 파트너와 함께 REST API를 도입했습니다. 이후 Amazon, Delicious(사이트 북마킹 웹 앱) 및 Flickr(사진 공유 앱)가 REST 기반 API를 제공하기 시작했습니다. 그런 다음 Amazon Web Services(AWS)는 Web 2.0(REST의 발명과 함께)을 활용하여 2006년에 AWS 클라우드 소비를 위해 개발자에게 REST API를 제공했습니다.</p><p id="-yqze6v_16">2024년 현재에는 REST API 없이 개발된 웹 애플리케이션을 거의 찾아볼 수 없습니다.</p></section><section class="chapter"><h2 id="1-2-rest" data-toc="1-2-rest">1.2 REST 기본 사항</h2><p id="-yqze6v_17">REST는 HTTP 프로토콜 위에서 작동합니다. 각 URI는 API 리소스로 작동합니다. 그러므로 동사 대신 명사를 엔드포인트로 사용해야 합니다.</p><div class="tabs" id="-yqze6v_18" data-anchors="[-yqze6v_19,-yqze6v_21]"><div class="tabs__content" data-gtm="tab" id="-yqze6v_19" data-title="RPC(원격 프로시저 호출)"><div class="code-block" data-lang="plaintext" data-title="Plain Text">/api/v1/getPersons</div></div><div class="tabs__content" data-gtm="tab" id="-yqze6v_21" data-title="REST"><div class="code-block" data-lang="plaintext" data-title="Plain Text">/api/v1/persons</div></div></div><p id="-yqze6v_23">그렇다면 REST 리소스에서 수행되는 다양한 작업을 어떻게 구별할 수 있는지 궁금할 것입니다.</p><p id="-yqze6v_24">답은 HTTP 메소드입니다. 예를 들어 GET(조회), DELETE(삭제), POST(생성), PUT(수정) 및 PATCH(부분 수정)와 같이 HTTP 메서드가 동사 역할을 하도록 만들 수 있습니다.</p><div class="code-block" data-lang="none">
    GET /api/v1/persons
    POST /api/v1/persons
    PUT /api/v1/persons/1
    DELETE /api/v1/persons/1
</div><p id="-yqze6v_30">REST 관점에서 보면 HTTP 요청은 자기 설명적이며 서버가 이를 처리할 수 있는 충분한 컨텍스트를 가지고 있습니다. 따라서 REST 호출은 상태 비저장입니다.</p><p id="-yqze6v_31">REST는 세 가지 주요 구성 요소를 사용하여 작동합니다.</p><ul class="list _bullet" id="-yqze6v_32"><li class="list__item" id="-yqze6v_33"><p>리소스와 URI</p></li><li class="list__item" id="-yqze6v_34"><p>HTTP 메소드</p></li><li class="list__item" id="-yqze6v_35"><p>HATEOAS</p></li></ul><p id="-yqze6v_36">일반적인 plain text의 REST API 호출은 다음과 같습니다.</p><div class="code-block" data-lang="none">
curl -v https://api.github.com/licenses
</div><div class="code-collapse" data-lang="none" data-is-expanded="false" data-synopsis="&gt; GET /licenses HTTP/2">

&gt; GET /licenses HTTP/2
&gt; Host: api.github.com
&gt; User-Agent: curl/8.6.0
&gt; Accept: */*
&gt;
&lt; HTTP/2 200
&lt; server: GitHub.com
&lt; date: Wed, 12 Jun 2024 02:00:58 GMT
&lt; content-type: application/json; charset=utf-8
&lt; cache-control: public, max-age=60, s-maxage=60
.
. 생략
.
&lt;
[
  {
    &quot;key&quot;: &quot;agpl-3.0&quot;,
    &quot;name&quot;: &quot;GNU Affero General Public License v3.0&quot;,
    &quot;spdx_id&quot;: &quot;AGPL-3.0&quot;,
    &quot;url&quot;: &quot;https://api.github.com/licenses/agpl-3.0&quot;,
    &quot;node_id&quot;: &quot;MDc6TGljZW5zZTE=&quot;
  },
  {
    &quot;key&quot;: &quot;apache-2.0&quot;,
    &quot;name&quot;: &quot;Apache License 2.0&quot;,
    &quot;spdx_id&quot;: &quot;Apache-2.0&quot;,
    &quot;url&quot;: &quot;https://api.github.com/licenses/apache-2.0&quot;,
    &quot;node_id&quot;: &quot;MDc6TGljZW5zZTI=&quot;
  },
.
. 생략
.

</div><p id="-yqze6v_39">여기서 /licenses 경로는 라이선스 리소스를 나타냅니다. <br> GET은 HTTP 메서드입니다. <br> 첫 번째 줄 끝에 있는 2는 HTTP 프로토콜 버전을 나타냅니다. <br> 두 번째 줄은 호출할 호스트를 공유합니다. <br> GitHub는 JSON 객체로 응답합니다. 응답 상태는 200 OK.</p></section><section class="chapter"><h2 id="1-3-http" data-toc="1-3-http">1.3 HTTP 메서드 및 상태 코드</h2><p id="-yqze6v_44">HTTP는 다양한 HTTP 메소드를 제공합니다. 그러나 기본적으로는 그 중 5개만 사용하게 됩니다.</p><ul class="list _bullet" id="-yqze6v_45"><li class="list__item" id="-yqze6v_46"><p>POST: 생성 또는 검색</p></li><li class="list__item" id="-yqze6v_47"><p>GET: 조회</p></li><li class="list__item" id="-yqze6v_48"><p>PUT: 수정</p></li><li class="list__item" id="-yqze6v_49"><p>DELETE: 삭제</p></li><li class="list__item" id="-yqze6v_50"><p>PATCH: 부분 수정</p></li></ul><section class="chapter"><h3 id="post" data-toc="post">POST</h3><p id="-yqze6v_51">HTTP POST는 일반적으로 리소스 생성을 하는 메소드입니다. 그러나 읽기 작업에 POST 메서드를 사용하려는 경우 특정 예외가 있습니다. 예) 필터 기준에 매개변수가 너무 많아 GET 호출의 길이 제한을 초과할 수 있는 검색 작업. <br> GET 쿼리 문자열은 256자로 제한됩니다. 또한 HTTP GET 메서드는 실제 경로의 문자 수를 뺀 최대 2,048자로 제한됩니다. (사실 아님) <br> 반면에 POST 방법은 Key, Value 쌍을 제출하기 위한 URL 크기에 의해 제한되지 않습니다.</p><p id="-yqze6v_54">또는 파라미터에 개인 정보 또는 보안 정보가 포함된 경우(비밀번호 찾기 등) 읽기 호출을 위해 HTTPS와 함께 POST 메서드를 사용할 수도 있습니다.</p><p id="-yqze6v_55">생성 작업 성공의 경우 <span class="control" id="-yqze6v_56">201 Created</span> 상태로 응답. <br> 검색 또는 읽기 작업 성공의 경우 호출이 HTTP POST 메서드를 사용하더라도 <span class="control" id="-yqze6v_58">200 OK</span> 또는 <span class="control" id="-yqze6v_59">204 No Content</span> 상태 코드를 사용.</p></section><section class="chapter"><h3 id="get" data-toc="get">GET</h3><p id="-yqze6v_60">HTTP GET 메서드는 일반적으로 리소스 읽기 작업을 하는 메서드입니다. <br> GET 작업은 응답에 데이터가 포함된 경우 <span class="control" id="-yqze6v_62">200 OK</span> 상태 코드 반환, 응답에 데이터가 포함되지 않은 경우 <span class="control" id="-yqze6v_63">204 No Content</span> 상태 코드를 반환합니다.</p></section><section class="chapter"><h3 id="put" data-toc="put">PUT</h3><p id="-yqze6v_64">HTTP PUT은 일반적으로 리소스 업데이트를 하는 메서드입니다. <br> 업데이트 작업 성공의 경우 응답에 데이터가 포함된 경우 <span class="control" id="-yqze6v_66">200 OK</span> 상태 코드 반환, 응답에 데이터가 포함되지 않은 경우 <span class="control" id="-yqze6v_67">204 No Content</span> 상태 코드를 반환합니다.</p></section><section class="chapter"><h3 id="delete" data-toc="delete">DELETE</h3><p id="-yqze6v_68">HTTP DELETE는 리소스 삭제 작업을 하는 메서드입니다. <br> DELETE 작업은 성공 시 <span class="control" id="-yqze6v_70">204 No Content</span> 상태 코드를 반환합니다.</p></section><section class="chapter"><h3 id="patch" data-toc="patch">PATCH</h3><p id="-yqze6v_71">HTTP PATCH는 부분 업데이트 리소스 작업을 하는 메서드입니다. 스프링 예전 버전에서는 지원하지 않았지만, 현재는 지원합니다. <br> PATCH 작업은 성공 시 <span class="control" id="-yqze6v_73">200 OK</span> 상태 코드를 반환합니다.</p></section></section><section class="chapter"><h2 id="http_status_codes" data-toc="http_status_codes">1.4 HTTP 상태 코드</h2><ul class="list _bullet" id="-yqze6v_74"><li class="list__item" id="-yqze6v_75"><p>정보 응답 (100-199)</p></li><li class="list__item" id="-yqze6v_76"><p>성공 응답 (200-299)</p></li><li class="list__item" id="-yqze6v_77"><p>리다이렉션 메시지 (300-399)</p></li><li class="list__item" id="-yqze6v_78"><p>클라이언트 에러 응답 (400-499)</p></li><li class="list__item" id="-yqze6v_79"><p>서버 에러 응답 (500-599)</p></li></ul><p id="-yqze6v_80"><a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Status" id="-yqze6v_81" data-external="true" rel="noopener noreferrer">MDN 웹 문서</a></p><div class="table-wrapper"><table class="wide" id="-yqze6v_82"><thead><tr class="ijRowHead" id="-yqze6v_83"><th id="-yqze6v_84"><p>HTTP Status Code</p></th><th id="-yqze6v_85"><p>Description</p></th></tr></thead><tbody><tr id="-yqze6v_86"><td id="-yqze6v_87"><p>200 OK</p></td><td id="-yqze6v_88"><p>요청 성공</p></td></tr><tr id="-yqze6v_89"><td id="-yqze6v_90"><p>201 Created</p></td><td id="-yqze6v_91"><p>생성 요청 성공</p></td></tr><tr id="-yqze6v_92"><td id="-yqze6v_93"><p>202 Accepted</p></td><td id="-yqze6v_94"><p>서버가 요청을 수락했지만 당장 응답을 할 수 없는 경우</p></td></tr><tr id="-yqze6v_95"><td id="-yqze6v_96"><p>204 No Content</p></td><td id="-yqze6v_97"><p>응답에 데이터가 포함되지 않은 성공의 경우</p></td></tr><tr id="-yqze6v_98"><td id="-yqze6v_99"><p>304 Not Modified</p></td><td id="-yqze6v_100"><p>캐싱에 사용. 리소스가 수정되지 않은 경우</p></td></tr><tr id="-yqze6v_101"><td id="-yqze6v_102"><p>400 Bad Request</p></td><td id="-yqze6v_103"><p>입력 매개변수가 올바르지 않거나 누락되었거나 요청 자체가 불완전한 경우</p></td></tr><tr id="-yqze6v_104"><td id="-yqze6v_105"><p>401 Unauthorized</p></td><td id="-yqze6v_106"><p>인증되지 않은 요청</p></td></tr><tr id="-yqze6v_107"><td id="-yqze6v_108"><p>403 Forbidden</p></td><td id="-yqze6v_109"><p>접근 권한이 없음</p></td></tr><tr id="-yqze6v_110"><td id="-yqze6v_111"><p>404 Not Found</p></td><td id="-yqze6v_112"><p>요청한 리소스가 존재하지 않을 때</p></td></tr><tr id="-yqze6v_113"><td id="-yqze6v_114"><p>500 Internal Server Error</p></td><td id="-yqze6v_115"><p>서버 오류로 인해 작업이 실패한 경우 (일반적인 오류)</p></td></tr><tr id="-yqze6v_116"><td id="-yqze6v_117"><p>502 Bad Gateway</p></td><td id="-yqze6v_118"><p>업스트림 서버 호출이 실패할 때(예: 앱이 타사 결제 서비스를 호출하지만 호출이 실패하는 경우)</p></td></tr><tr id="-yqze6v_119"><td id="-yqze6v_120"><p>503 Service Unavailable</p></td><td id="-yqze6v_121"><p>서버에서 예기치 않은 일이 발생한 경우</p></td></tr></tbody></table></div></section><section class="chapter"><h2 id="1-5-hateoas-hypermedia-as-the-engine-of-application-state" data-toc="1-5-hateoas-hypermedia-as-the-engine-of-application-state">1.5 HATEOAS(Hypermedia As The Engine Of Application State)</h2><p id="-yqze6v_122">HATEOAS를 사용하면 RESTful 웹 서비스는 하이퍼미디어를 통해 정보를 동적으로 제공합니다. 하이퍼미디어는 REST 호출 응답에서 받는 콘텐츠의 일부입니다. 이 하이퍼미디어 콘텐츠에는 텍스트, 이미지, 비디오 등 다양한 유형의 미디어에 대한 링크가 포함되어 있습니다.</p><p id="-yqze6v_123">하이퍼미디어 링크는 HTTP 헤더나 응답 본문에 포함될 수 있습니다. GitHub API를 살펴보면 GitHub API가 하이퍼미디어 링크를 헤더와 응답 본문 모두에 제공한다는 것을 알 수 있습니다. GitHub는 페이징 관련 링크를 담은 Link라는 헤더를 사용합니다. 게다가 GitHub API의 응답을 살펴보면 url 접미사를 가진 키로 다른 리소스 관련 링크도 찾을 수 있습니다. 예시를 살펴보겠습니다. GET /users 리소스를 요청하고 응답을 분석해 봅시다.</p><div class="code-block" data-lang="none">
curl -v https://api.github.com/users
</div><div class="code-collapse" data-lang="none" data-is-expanded="false" data-synopsis="&gt; GET /users HTTP/2">

&gt; GET /users HTTP/2
&gt; Host: api.github.com
&gt; User-Agent: curl/8.6.0
&gt; Accept: */*
&gt;
&lt; HTTP/2 200
&lt; server: GitHub.com
&lt; date: Wed, 12 Jun 2024 05:51:09 GMT
&lt; content-type: application/json; charset=utf-8
&lt; cache-control: public, max-age=60, s-maxage=60
&lt; vary: Accept, Accept-Encoding, Accept, X-Requested-With
&lt; etag: W/&quot;003f9f002943ba1f9762a7eef39fd9cf8ae4af5ad9e49b9f0cf59e7533972fb6&quot;
&lt; x-github-media-type: github.v3; format=json
&lt; link: &lt;https://api.github.com/users?since=46&gt;; rel=&quot;next&quot;, &lt;https://api.github.com/users{?since}&gt;; rel=&quot;first&quot;
.
. 생략
.
&lt; accept-ranges: bytes
&lt; content-length: 29925
&lt; x-github-request-id: A1FE:BB661:77A097:7A666E:6669374D
&lt;
[
  {
    &quot;login&quot;: &quot;mojombo&quot;,
    &quot;id&quot;: 1,
    &quot;node_id&quot;: &quot;MDQ6VXNlcjE=&quot;,
    &quot;avatar_url&quot;: &quot;https://avatars.githubusercontent.com/u/1?v=4&quot;,
    &quot;gravatar_id&quot;: &quot;&quot;,
    &quot;url&quot;: &quot;https://api.github.com/users/mojombo&quot;,
    &quot;html_url&quot;: &quot;https://github.com/mojombo&quot;,
    &quot;followers_url&quot;: &quot;https://api.github.com/users/mojombo/followers&quot;,
    &quot;following_url&quot;: &quot;https://api.github.com/users/mojombo/following{/other_user}&quot;,
    &quot;gists_url&quot;: &quot;https://api.github.com/users/mojombo/gists{/gist_id}&quot;,
    &quot;starred_url&quot;: &quot;https://api.github.com/users/mojombo/starred{/owner}{/repo}&quot;,
    &quot;subscriptions_url&quot;: &quot;https://api.github.com/users/mojombo/subscriptions&quot;,
    &quot;organizations_url&quot;: &quot;https://api.github.com/users/mojombo/orgs&quot;,
    &quot;repos_url&quot;: &quot;https://api.github.com/users/mojombo/repos&quot;,
    &quot;events_url&quot;: &quot;https://api.github.com/users/mojombo/events{/privacy}&quot;,
    &quot;received_events_url&quot;: &quot;https://api.github.com/users/mojombo/received_events&quot;,
    &quot;type&quot;: &quot;User&quot;,
    &quot;site_admin&quot;: false
  },

</div><p id="-yqze6v_126">출력에서 Link 헤더에 페이지네이션 정보가 포함되어 있음을 알 수 있습니다. 다음 페이지와 첫 페이지로 이동하는 링크가 응답의 일부로 제공됩니다. 또한 응답 본문에는 avatar_url이나 followers_url과 같은 많은 URL이 포함되어 있어 다른 하이퍼미디어로 이어지는 링크를 제공합니다.</p><p id="-yqze6v_127">REST 클라이언트는 서버와 상호 작용하는 방법에 대한 구체적인 지식이 없어도 RESTful 웹 서비스와 상호 작용할 수 있도록 하이퍼미디어에 대한 이해를 어느정도는 하고 있어야 합니다. REST는 동적으로 링크를 제공하고, 클라이언트가 링크를 탐색하여 적절한 리소스로 이동할 수 있도록 돕습니다.</p><p id="-yqze6v_128">HATEOAS는 REST의 매우 중요한 개념입니다. 이는 REST를 RPC와 구별하는 개념 중 하나입니다.</p><ul class="list _bullet" id="-yqze6v_129"><li class="list__item" id="-yqze6v_130"><p>RPC는 클라이언트가 서버에 대해 명령을 내리는 방식이며, 클라이언트는 서버에 대한 지식이 필요합니다.</p></li><li class="list__item" id="-yqze6v_131"><p>반면에 REST는 클라이언트가 서버에 대해 명령을 내리는 방식이 아니라 클라이언트가 서버에 대한 정보를 받아서 이를 통해 서버와 상호 작용하는 방식입니다.</p></li></ul><p id="-yqze6v_132"><a href="https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven" id="-yqze6v_133" data-external="true" rel="noopener noreferrer">REST API는 하이퍼미디어 주도여야 한다.</a></p></section><section class="chapter"><h2 id="rest-api_1" data-toc="rest-api_1">1.6 REST API를 설계하는 방법</h2><dl id="-yqze6v_134" data-style="title-top"><dt id="-yqze6v_135" data-expandable="false"><span class="control" id="-yqze6v_137">엔드포인트 경로에서 리소스의 이름을 지을 때 동사가 아닌 명사를 사용합니다.</span></dt><dd><ul class="list _bullet" id="-yqze6v_138"><li class="list__item" id="-yqze6v_139"><p>HTTP 메소드는 동사를 사용합니다. 따라서 본인이 동사를 사용하는 것은 중복되며, 호출이 RPC 엔드포인트처럼 보이게 됩니다. 예를 들어 GET /getLicenses와 같이요.</p></li><li class="list__item" id="-yqze6v_140"><p>예를 들어 GitHub 라이선스 API를 다시 살펴보겠습니다. 라이선스를 검색하는 API는 GET /licenses입니다. 이 엔드포인트에 동사를 사용한다면 GET /getlicenses가 될 것입니다. 여전히 작동하지만 의미론적으로 REST를 따르지 않습니다. 왜냐하면 상태 전송이 아닌 처리 명령을 전달하기 때문입니다.</p></li></ul></dd><dt id="-yqze6v_141" data-expandable="false"><span class="control" id="-yqze6v_143">엔드포인트 경로에서 컬렉션 리소스를 명명할 때 복수형을 사용합니다.</span></dt><dd><ul class="list _bullet" id="-yqze6v_144"><li class="list__item" id="-yqze6v_145"><p>GitHub 라이선스 API를 관찰하면, 리소스 이름이 복수형으로 제공되는 것을 발견할 수 있습니다. 리소스가 컬렉션을 나타낸다면 복수형을 사용하는 것이 좋은 관행입니다. 따라서 /license 대신에 /licenses를 사용할 수 있습니다.</p></li></ul></dd><dt id="-yqze6v_146" data-expandable="false"><span class="control" id="-yqze6v_148">하이퍼미디어(HATEOAS)를 사용합니다.</span></dt><dd><ul class="list _bullet" id="-yqze6v_149"><li class="list__item" id="-yqze6v_150"><p>하이퍼미디어(즉, 다른 리소스로의 링크)는 REST 클라이언트의 작업을 쉽게 만듭니다. 응답에 명시적인 URL 링크를 제공하는 경우 두 가지 이점이 있습니다.</p></li></ul><ol class="list _decimal" id="-yqze6v_151" type="1"><li class="list__item" id="-yqze6v_152"><p>REST 클라이언트는 REST URL을 직접 구성할 필요가 없습니다.</p></li><li class="list__item" id="-yqze6v_153"><p>엔드포인트 경로의 변경이 자동으로 처리되므로 클라이언트와 개발자에게 업데이트 작업이 더 쉬워집니다. </p><br><p><a href="https://terms.tta.or.kr/dictionary/dictionaryView.do?subject=%ED%95%98%EC%9D%B4%ED%8D%BC%EB%AF%B8%EB%94%94%EC%96%B4" id="-yqze6v_155" data-external="true" rel="noopener noreferrer">하이퍼미디어란?</a></p></li></ol></dd><dt id="-yqze6v_156" data-expandable="false"><span class="control" id="-yqze6v_158">API 버전을 관리합니다.</span></dt><dd><ul class="list _bullet" id="-yqze6v_159"><li class="list__item" id="-yqze6v_160"><p>시간이 지남에 따라 API는 계속 변화하고 이전 버전을 사용하는 고객이 있을 수 있습니다. 따라서 여러 버전의 API를 지원해야 합니다.</p></li></ul><ol class="list _decimal" id="-yqze6v_161" type="1"><li class="list__item" id="-yqze6v_162"><p>HTTP 헤더에 추가: <code class="code" id="-yqze6v_163">Accept: application/vnd.github.v3+json</code></p></li><li class="list__item" id="-yqze6v_164"><p>엔드포인트 경로 사용: <code class="code" id="-yqze6v_165">https://demo.app/api/v1/persons</code></p></li></ol></dd><dt id="-yqze6v_166" data-expandable="false"><span class="control" id="-yqze6v_168">중첩된 리소스</span></dt><dd><ul class="list _bullet" id="-yqze6v_169"><li class="list__item" id="-yqze6v_170"><p>중첩되거나 특정 관계를 갖는 리소스의 엔드포인트를 어떻게 구성할 것인가에 대한 문제입니다.</p></li></ul><ol class="list _decimal" id="-yqze6v_171" type="1"><li class="list__item" id="-yqze6v_172"><p><code class="code" id="-yqze6v_173">GET /customers/1/addresses</code>: 고객 1의 주소 목록을 반환</p></li><li class="list__item" id="-yqze6v_174"><p><code class="code" id="-yqze6v_175">GET /customers/1/addresses/2</code>: 고객 1의 두번째 주소를 반환</p></li><li class="list__item" id="-yqze6v_176"><p><code class="code" id="-yqze6v_177">POST /customers/1/addresses</code>: 고객 1에 새 주소를 추가</p></li><li class="list__item" id="-yqze6v_178"><p><code class="code" id="-yqze6v_179">PUT /customers/1/addresses/2</code>: 고객 1의 두번째 주소를 대체</p></li><li class="list__item" id="-yqze6v_180"><p><code class="code" id="-yqze6v_181">PATCH /customers/1/addresses/2</code>: 고객 1의 두번째 주소를 부분적으로 수정</p></li><li class="list__item" id="-yqze6v_182"><p><code class="code" id="-yqze6v_183">DELETE /customers/1/addresses/2</code>: 고객 1의 두번째 주소를 삭제</p><br><p> 문제 없습니다. 그럼 이 중첩된 리소스를 분리할 수 있을까요? <code class="code" id="-yqze6v_185">GET /addresses/2</code>로 주소를 가져올 수 있을까요? 필요하면 할 수 있죠. </p><br><p> 예를 들어, 주문과 결제 <code class="code" id="-yqze6v_187">/orders/1/payments/1</code> 리소스를 <code class="code" id="-yqze6v_188">/payments/1</code>로 분리하고 싶을 수 있습니다. 마이크로서비스라면 이게 더 좋을 수 있습니다. 주문서비스와 결제서비스가 분리되어 있기 때문입니다. 이걸 하이퍼미디어와 결합하면 쉬워집니다. 예를 들어보죠.</p></li><li class="list__item" id="-yqze6v_189"><p><code class="code" id="-yqze6v_190">GET /orders/1</code>: 주문 1을 반환</p></li><li class="list__item" id="-yqze6v_191"><p>1번 리소스에 포함된 하이퍼미디어 정보에 <code class="code" id="-yqze6v_192">/payments/1</code> 링크를 제공</p></li><li class="list__item" id="-yqze6v_193"><p><code class="code" id="-yqze6v_194">GET /payments/1</code>: 결제 1을 반환</p><br><p> 무엇이 더 좋은지 절대적인 규칙이나 잣대는 없습니다. 첫번째 예의 경우 웹 요청이 줄어드는 장점이 있고 두번째 예의 경우 API 설계가 간단해지며 마이크로서비스 아키텍처에 적합합니다.</p></li></ol></dd><dt id="-yqze6v_196" data-expandable="false"><span class="control" id="-yqze6v_198">API 보안에 신경쓰세요.</span></dt><dd><ul class="list _bullet" id="-yqze6v_199"><li class="list__item" id="-yqze6v_200"><p>암호화 된 통신을 위해 항상 HTTPS를 사용하세요.</p></li><li class="list__item" id="-yqze6v_201"><p>안전한 REST API는 인증이 되어 있어야 합니다. REST API는 상태를 유지하지 않으므로 쿠키나 세션을 이용하면 안됩니다. 대신 JWT나 OAuth 2.0 기반의 토큰을 사용하여 보안을 유지해야 합니다.</p></li></ul></dd><dt id="-yqze6v_202" data-expandable="false"><span class="control" id="-yqze6v_204">API 사양에 대한 문서화를 신경쓰세요.</span></dt><dd><ul class="list _bullet" id="-yqze6v_205"><li class="list__item" id="-yqze6v_206"><p>문서는 쉽게 접근 가능하고 최신 구현에 맞게 업데이트되어 있어야 합니다. 샘플 코드와 예제를 제공하는 것이 항상 좋습니다.</p></li></ul></dd></dl></section><section class="chapter"><h2 id="1-7-e" data-toc="1-7-e">1.7 e-커머스 앱 개요</h2><p id="-yqze6v_207">우리가 만들 e-커머스 앱은 사용자를 위한 다음 기능을 갖춘 간단한 온라인 쇼핑 애플리케이션입니다.</p><ul class="list _bullet" id="-yqze6v_208"><li class="list__item" id="-yqze6v_209"><p>제품 둘러보기</p></li><li class="list__item" id="-yqze6v_210"><p>장바구니에 제품 추가 / 제거 / 수정하기</p></li><li class="list__item" id="-yqze6v_211"><p>주문하기</p></li><li class="list__item" id="-yqze6v_212"><p>배송 주소 수정</p></li></ul><p id="-yqze6v_213">바운디드 컨텍스트를 통해 응용 프로그램을 다음 하위 도메인으로 나눌 수 있습니다. <br><a href="https://madini.tistory.com/35" id="-yqze6v_215" data-external="true" rel="noopener noreferrer">바운디드 컨텍스트(Bounded Contexts)란?</a></p><ul class="list _bullet" id="-yqze6v_216"><li class="list__item" id="-yqze6v_217"><p>Users: 이 하위 도메인은 사용자와 관련이 있습니다. 사용자 RESTful 웹 서비스를 추가할 것이며, 사용자 관리를 위한 REST API를 제공합니다.</p></li><li class="list__item" id="-yqze6v_218"><p>Carts: 이 하위 도메인은 장바구니와 관련이 있습니다. 장바구니 RESTful 웹 서비스를 추가할 것이며, 장바구니 관리를 위한 REST API를 제공합니다. 사용자는 카트 항목에 대해 CRUD 작업을 수행할 수 있습니다.</p></li><li class="list__item" id="-yqze6v_219"><p>Products: 이 하위 도메인은 제품과 관련이 있습니다. 제품 RESTful 웹 서비스를 추가할 것이며, 제품 관리를 위한 REST API를 제공하여 제품을 검색하고 검색 결과를 가져올 수 있습니다.</p></li><li class="list__item" id="-yqze6v_220"><p>Orders: 이 하위 도메인은 주문과 관련이 있습니다. 주문 RESTful 웹 서비스를 추가할 것이며, 사용자가 주문을 할 수 있는 REST API를 제공합니다.</p></li><li class="list__item" id="-yqze6v_221"><p>Payments: 이 하위 도메인은 결제와 관련이 있습니다. 결제 RESTful 웹 서비스를 추가할 것이며, 이는 결제 처리를 위한 REST API를 제공합니다.</p></li><li class="list__item" id="-yqze6v_222"><p>Shippings: 이 하위 도메인은 배송과 관련이 있습니다. 주문 추적 및 배송을 위한 RESTful 웹 서비스를 추가할 것입니다.</p></li></ul><figure id="-yqze6v_223"><img alt="application_architecture.png" src="images/application_architecture.png" title="application_architecture.png" width="1650" height="918"></figure><p id="-yqze6v_224">다음 장에서는 Spring Framework의 기초에 대해 배우게 될 것입니다.</p></section><section class="chapter"><h2 id="1-8" data-toc="1-8">1.8 복습</h2><ol class="list _decimal" id="-yqze6v_225" type="1"><li class="list__item" id="-yqze6v_226"><p>왜 RESTful 웹 서비스가 그렇게 인기를 얻었고 산업 표준이 된 것인가요?</p></li><li class="list__item" id="-yqze6v_227"><p>RPC와 REST의 차이점은 무엇인가요?</p></li><li class="list__item" id="-yqze6v_228"><p>HATEOAS를 어떻게 설명하겠습니까?</p></li><li class="list__item" id="-yqze6v_229"><p>서버 관련 문제에 사용해야 하는 오류 코드는 무엇입니까?</p></li><li class="list__item" id="-yqze6v_230"><p>동사를 사용하여 REST 엔드포인트를 제공하는 이유가 무엇인가요?</p></li></ol></section><div class="last-modified">Last modified: 20 6월 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="chapter02.html" class="navigation-links__next">Chapter 2 - Spring Framework 기초</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b267/app.js"></script></body></html>