<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-06-20T13:56:41.496791"><title>Chapter 5 - 비동기 API 디자인 (필수 아님) | Infosiatec Workshop</title><script type="application/json" id="virtual-toc-data">[{"id":"i74vva2_5","level":0,"title":"이번 장의 목표","anchor":"#i74vva2_5"},{"id":"5-1","level":0,"title":"5.1 반응형 스트림 이해하기","anchor":"#5-1"},{"id":"5-2-spring-webflux","level":0,"title":"5.2 Spring WebFlux 사용해보기","anchor":"#5-2-spring-webflux"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b267/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Chapter 5 - 비동기 API 디자인 (필수 아님) | Infosiatec Workshop"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Infosiatec Workshop Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/chapter05.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Chapter 5 - 비동기 API 디자인 (필수 아님) | Infosiatec Workshop"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/chapter05.html#webpage",
    "url": "writerside-documentation/chapter05.html",
    "name": "Chapter 5 - 비동기 API 디자인 (필수 아님) | Infosiatec Workshop",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Infosiatec Workshop Help"
}</script><!-- End Schema.org --></head><body data-id="Chapter05" data-main-title="Chapter 5 - 비동기 API 디자인 (필수 아님)" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs=""><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Infosiatec Workshop  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Chapter05" id="Chapter05.md">Chapter 5 - 비동기 API 디자인 (필수 아님)</h1><p id="i74vva2_3">지금까지 동기 호출을 기반으로 한 명령형 모델에 따라 RESTful 웹 서비스를 개발해 왔습니다. 그렇다면 코드를 비동기 및 논블로킹으로 만들고 싶다면 어떻게 해야 할까요? 이 챕터에서는 비동기 및 논블로킹 호출이 있는 비동기 API 설계에 대해 배우게 될 것입니다. 우리는 Spring WebFlux를 사용하여 이러한 API를 개발할 것이며, Project Reactor(https://projectreactor.io)를 기반으로 합니다. Reactor는 Java 가상 머신(JVM)에서 논블로킹 앱을 구축하기 위한 라이브러리입니다.</p><p id="i74vva2_4">먼저 반응형 프로그래밍의 기본을 살펴본 후, 기존의 전자 상거래 REST API(우리가 4장에서 배운 API를 위한 비즈니스 로직 작성)를 비교를 통해 기존의 (명령형) 방식과 반응형 프로그래밍 방식을 비교하여 더 쉽게 만들기 위해 비동기 (반응형) API로 이관할 것입니다. 코드는 데이터베이스 지속성을 위해 반응형 프로그래밍을 지원하는 R2DBC를 사용할 것입니다.</p><section class="chapter"><h2 id="i74vva2_5" data-toc="i74vva2_5">이번 장의 목표</h2><ul class="list _bullet" id="i74vva2_6"><li class="list__item" id="i74vva2_7"><p>반응형 스트림 이해하기</p></li><li class="list__item" id="i74vva2_8"><p>Spring WebFlux를 사용해보기</p></li><li class="list__item" id="i74vva2_9"><p>디스패처 핸들러(Dispatch Handler) 이해</p></li><li class="list__item" id="i74vva2_10"><p>Controller</p></li><li class="list__item" id="i74vva2_11"><p>Functional Endpoints</p></li><li class="list__item" id="i74vva2_12"><p>e-commerce REST API를 반응형으로 변환하기</p></li></ul></section><section class="chapter"><h2 id="5-1" data-toc="5-1">5.1 반응형 스트림 이해하기</h2><p id="i74vva2_13">전통적인 자바 프로그래밍에서 비동기 처리를 하려면 어떻게 해야 하나요? Thread를 사용하죠. 톰캣의 경우 일반적으로 요청 하나 당 하나의 스레드가 할당됩니다. 어플리케이션은 DB 연결에도 스레드 풀을 사용합니다. 따라서 각 웹 요청과 데이터베이스 호출은 고유의 스레드를 사용합니다. 요청 스레드는 DB 쿼리가 완료될 때까지 대기해야 합니다. 이것이 블로킹(동기) I/O입니다. 이러한 방식은 많은 요청이 동시에 발생할 때 확장성이 떨어집니다.</p><p id="i74vva2_14">지난 10년 동안 클라이언트-서버 아키텍처가 증가했습니다. 많은 IoT 기기, 네이티브 앱을 갖춘 스마트폰, 일류 웹 앱, 그리고 전통적인 웹 애플리케이션이 등장했습니다. 애플리케이션은 제3자 서비스 뿐만 아니라 다양한 데이터 소스도 갖추고 있어 더 큰 규모의 애플리케이션을 유발합니다. 더불어, 마이크로서비스 기반 아키텍처는 서비스 간 통신을 증가시켰습니다. 이에 따라 높은 네트워크 통신 수요를 충족하기 위해 많은 자원이 필요합니다. 스레드는 비용이 많이 들고 무한히 만들 수도 없습니다. (자바 21부터는 Virtual Thread가 등장)</p><p id="i74vva2_15">어떻게 해결할 수 있을까요? 예를 들어, 코드가 데이터베이스에서 데이터를 호출하는 경우를 생각해보죠. 이 경우, 호출은 응답을 받을 때까지 blocking call에서 기다립니다. 그렇지만 non-blocking call은 아무것도 기다리지 않습니다. 데이터베이스로 요청을 보내고 다른 일을 하다가 데이터베이스의 응답이 오면 그때 처리합니다. 이것이 non-blocking 입니다. Project Reactor는 Reactive Streams를 기반으로 합니다. Reactive Streams는 데이터의 소스인 발행자가 데이터를 구독자에게 밀어넣는 발행-구독(publisher-subscriber) 모델을 사용합니다.</p><p id="i74vva2_16">Node.js는 대부분의 자원을 활용하기 위해 단일 스레드를 사용합니다. 이는 이벤트 루프로 알려진 비동기 논블로킹 디자인에 기반하고 있습니다.</p><p id="i74vva2_17">반응형 API는 이벤트 루프 디자인을 기반으로 하며 푸시 스타일 알림을 사용합니다. Reactive Streams는 또한 Java 스트림(여러 작업을 수행하여 원하는 결과를 생성하기 위해 파이프라인으로 연결된 객체의 시퀀스) 작업인 map, flatMap, filter와 같은 작업을 지원합니다. 내부적으로 Reactive Streams는 푸시 스타일(발행자가 구독자에게 데이터를 밀어넣음)을 사용하며, Java 스트림은 풀 모델(구독자가 요청을 하면 데이터가 준비가 됐을 때 끌어다 씀)에 따라 작동합니다. 즉, 풀 모델의 경우 아이템을 Java 컬렉션과 같은 소스에서 끌어다 씁니다. 반면 반응형 프로그래밍에서 소스(발행자)는 데이터를 구독자에게 밀어넣습니다.</p><p id="i74vva2_18">리액티브 스트림에서 데이터 스트림은 비동기적이고 논블로킹이며 백프레셔를 지원합니다. (백프레셔는 이후 설명)</p><p id="i74vva2_19">리액티브 스트림 명세에 따르면 기본적으로 네 가지 유형의 인터페이스가 있습니다:</p><ul class="list _bullet" id="i74vva2_20"><li class="list__item" id="i74vva2_21"><p>Publisher: 데이터를 생성하고 발행하는 객체</p></li><li class="list__item" id="i74vva2_22"><p>Subscriber: 데이터를 소비하는 객체</p></li><li class="list__item" id="i74vva2_23"><p>Subscription: Publisher와 Subscriber 사이의 연결</p></li><li class="list__item" id="i74vva2_24"><p>Processor: Publisher와 Subscriber 사이에서 데이터를 변환하는 객체</p></li></ul><section class="chapter"><h3 id="publisher" data-toc="publisher">Publisher</h3><p id="i74vva2_25">발행자는 하나 이상의 구독자에게 데이터 스트림을 제공합니다. 구독자는 subscribe() 메서드를 사용하여 발행자를 구독합니다. 각 구독자는 발행자를 한 번만 구독해야 합니다. 가장 중요한 것은 발행자가 구독자로부터 받은 요구에 따라 데이터를 밀어 넣는다는 점입니다. Reactive Streams는 '게으르다'는 의미의 'lazy' 특성을 가지고 있습니다. 이는 발행자가 구독자가 실제로 존재하고 요청할 때만 데이터를 전달(push)한다는 의미입니다. <br> 여기서 'lazy'는 프로그래밍 컨텍스트에서 특정 작업이 실제로 필요한 시점까지 지연되는 특성을 의미합니다. 이는 불필요한 작업을 최소화하고, 성능을 향상시키는 데 도움이 됩니다. 따라서 이 문장에서 'lazy'는 발행자가 데이터를 미리 생성하거나 전달하지 않고, 구독자가 실제로 데이터를 요청할 때만 데이터를 생성하고 전달한다는 의미로 사용되었습니다.</p></section><section class="chapter"><h3 id="subscriber" data-toc="subscriber">Subscriber</h3><p id="i74vva2_27">구독자는 발행자가 푸시한 데이터를 사용합니다. 발행자-구독자 간 통신은 다음과 같이 작동합니다:</p><ol class="list _decimal" id="i74vva2_28" type="1"><li class="list__item" id="i74vva2_29"><p>Subscriber 인스턴스가 <span id="i74vva2_30"><b><font style="color:#ff7f50">Publisher.subscribe()</font></b></span> 메서드에 전달되면 <span id="i74vva2_31"><b><font style="color:#ff7f50">onSubscribe()</font></b></span> 메서드가 트리거됩니다.</p></li><li class="list__item" id="i74vva2_32"><p>첫 번째 단계 이후, 발행자는 <span id="i74vva2_33"><b><font style="color:#ff7f50">Subscription.request(long)</font></b></span> 호출을 기다립니다. <span id="i74vva2_34"><b><font style="color:#ff7f50">Subscription.request()</font></b></span> 호출이 이루어진 후에만 발행자가 구독자에게 데이터를 푸시합니다.</p></li></ol><p id="i74vva2_35">일반적으로 발행자는 구독자가 안전하게 처리할 수 있는지 여부와 관계없이 데이터를 구독자에게 전달합니다. 그러나 구독자는 그 자신만이 안전하게 처리할 수 있는 데이터 양을 가장 잘 알기 때문에 Reactive Streams에서는 구독자가 Subscription 인스턴스를 사용하여 발행자에게 필요한 요소의 양에 대한 수요를 전달합니다. 이를 백프레셔(back-pressure) 또는 흐름 제어(flow control)라고 합니다.</p><p id="i74vva2_36">이런 경우도 생각해볼 수 있겠습니다. 만일 발행자가 구독자에게 처리속도를 좀 낮추라고 요청했는데 구독자가 그 요청을 무시한다면 어떻게 될까요? 발행자는 이걸 실패처리를 할지 drop을 할지 아니면 버퍼링으로 처리할지 결정해야 합니다.</p><ol class="list _decimal" id="i74vva2_37" type="1" start="3"><li class="list__item" id="i74vva2_38"><p>2에서 요청이 발생하면 발행자는 데이터 통지를 보내고 <span id="i74vva2_39"><b><font style="color:#ff7f50">onNext()</font></b></span> 메서드를 사용하여 데이터를 소비합니다. 이 메서드는 구독자의 <span id="i74vva2_40"><b><font style="color:#ff7f50">Subscription.request()</font></b></span>에 의해 전달된 요청에 따라 발행자가 데이터 통지를 보낼 때까지 계속해서 트리거됩니다.</p></li><li class="list__item" id="i74vva2_41"><p>결국에는 처리 상태에 따라 <span id="i74vva2_42"><b><font style="color:#ff7f50">onError()</font></b></span> 또는 <span id="i74vva2_43"><b><font style="color:#ff7f50">onComplete()</font></b></span> 메서드가 어느쪽이든 트리거될 것입니다. 이들 중 하나가 호출되면, <span id="i74vva2_44"><b><font style="color:#ff7f50">Subscription.request()</font></b></span>를 다시 호출하더라도 구독자에게 더 이상 알림이 전송되지 않습니다. </p><ul class="list _bullet" id="i74vva2_45"><li class="list__item" id="i74vva2_46"><p><span id="i74vva2_47"><b><font style="color:#ff7f50">onError(Throwable t)</font></b></span>: 데이터 스트림에서 오류가 발생하면 이 메소드가 호출됩니다. Throwable 인수는 발생한 오류를 나타냅니다. 이 메소드가 호출되면, 구독자에게 더 이상 알림이 전송되지 않습니다.</p></li><li class="list__item" id="i74vva2_48"><p><span id="i74vva2_49"><b><font style="color:#ff7f50">onComplete()</font></b></span>: 데이터 스트림이 성공적으로 완료되면 이 메소드가 호출됩니다. 이 메소드가 호출되면, 구독자에게 더 이상 알림이 전송되지 않습니다.</p></li></ul></li></ol></section><section class="chapter"><h3 id="subscription" data-toc="subscription">Subscription</h3><p id="i74vva2_50">구독은 발행자과 구독자 사이의 중재자입니다. <span id="i74vva2_51"><b><font style="color:#ff7f50">Subscription.subscriber()</font></b></span> 메서드를 호출하고 발행자에게 필요한 수요를 알리는 것은 구독자의 책임입니다. 구독자가 필요할 때마다 호출될 수 있습니다.</p><p id="i74vva2_52"><span id="i74vva2_53"><b><font style="color:#ff7f50">cancel()</font></b></span> 메서드는 발행자에게 데이터 알림을 중지하고 리소스 정리를 요청합니다.</p></section><section class="chapter"><h3 id="processor" data-toc="processor">Processor</h3><p id="i74vva2_54">프로세서는 발행자와 구독자 사이의 다리 역할을 하며 처리 단계를 나타냅니다. 발행자와 구독자 모두로 작동하며 둘 모두가 정의한 계약을 준수합니다.</p><p id="i74vva2_55">다음 예제를 살펴보겠습니다. 여기서는 <span id="i74vva2_56"><b><font style="color:#ff7f50">Flux.just()</font></b></span> 정적 팩토리 메서드를 사용하여 Flux를 생성하고 있습니다. Flux는 Project Reactor에서 사용되는 publisher의 한 종류입니다. 이 publisher에는 네 개의 정수가 포함되어 있습니다. 그런 다음, reduce 연산자(Java 스트림에서 하는 것과 같이)를 사용하여 합산 작업을 수행합니다:</p><div class="code-block" data-lang="java">
Flux&lt;Integer&gt; fluxInt = Flux.just(1, 10, 100, 1000).log();
fluxInt.reduce(Integer::sum)
  .subscribe(sum -&gt; System.out.printf(&quot;Sum is: %d&quot;, sum));
</div><p id="i74vva2_58">실행하면 다음과 같은 결과가 출력됩니다:</p><div class="code-block" data-lang="bash">
11:00:38.074 [main] INFO reactor.Flux.Array.1 - | onSubscribe([Synchronous Fuseable] FluxArray.ArraySubscription)
11:00:38.074 [main] INFO reactor.Flux.Array.1 - | request(unbounded)
11:00:38.084 [main] INFO reactor.Flux.Array.1 - | onNext(1)
11:00:38.084 [main] INFO reactor.Flux.Array.1 - | onNext(10)
11:00:38.084 [main] INFO reactor.Flux.Array.1 - | onNext(100)
11:00:38.084 [main] INFO reactor.Flux.Array.1 - | onNext(1000)
11:00:38.084 [main] INFO reactor.Flux.Array.1 - | onComplete() Sum is: 1111
Process finished with exit code 0
</div><p id="i74vva2_60">출력을 살펴보면 Publisher가 구독되면 Subscriber가 무제한 <span id="i74vva2_61"><b><font style="color:#ff7f50">Subscription.request()</font></b></span>를 보냅니다. 첫 번째 요소가 통지되면 <span id="i74vva2_62"><b><font style="color:#ff7f50">onNext()</font></b></span>가 호출되고, 반복됩니다. 마지막으로, 푸시 요소를 완료한 후에는 <span id="i74vva2_63"><b><font style="color:#ff7f50">onComplete()</font></b></span> 이벤트가 호출됩니다. 이것이 Reactive Streams가 작동하는 방식입니다.</p></section></section><section class="chapter"><h2 id="5-2-spring-webflux" data-toc="5-2-spring-webflux">5.2 Spring WebFlux 사용해보기</h2><p id="i74vva2_64">기존 서블릿 API는 블로킹 API입니다. 입력 및 출력 스트림을 사용하며, 블로킹 API입니다. 서블릿 3.0 컨테이너는 진화하여 기본 이벤트 루프를 사용합니다. 비동기 요청은 비동기적으로 처리되지만 읽기 및 쓰기 작업은 여전히 블로킹 입력/출력 스트림을 사용합니다. 서블릿 3.1 컨테이너는 더 발전하여 비동기성을 지원하며 논블로킹 I/O 스트림 API를 갖추고 있습니다. 그러나 <span id="i74vva2_65"><b><font style="color:#ff7f50">request.getParameters()</font></b></span>와 같은 일부 서블릿 API는 요청 본문을 읽어들이는 동안 다른 작업을 진행하지 못하게 막습니다. <span id="i74vva2_66"><b><font style="color:#ff7f50">Filter</font></b></span>와 같은 기능들은 동기적으로 동작하므로, 한 작업이 완료될 때까지 다음 작업은 대기해야 합니다. Spring MVC 프레임워크는 서블릿 API와 서블릿 컨테이너를 기반으로 합니다. 결국 기존 서블릿 기반으로는 완전한 논블로킹 API를 만들기 어렵습니다.</p><p id="i74vva2_67">그래서 Spring은 완전 비차단이며 백프레셔 기능을 제공하는 Spring WebFlux를 제공합니다. 적은 스레드 수로 동시성을 제공하며 적은 하드웨어 리소스로 확장이 가능합니다. WebFlux는 선언적 비동기 논리의 조합을 지원하기 위해 fluent(method chaining)하고 functional하고 끊임없이 계속되는 스타일의 API를 제공합니다. 비동기 함수형 코드를 작성하는 것은 명령형 스타일 코드를 작성하는 것보다 복잡합니다. 그러나 한 번 익숙해지면 정확하고 가독성 있는 코드를 작성할 수 있어서 장점이 큽니다.</p><p id="i74vva2_68">Spring WebFlux와 Spring MVC는 함께 사용할 수 있지만, 반응형 프로그래밍을 효과적으로 사용하기 위해서는 반응형 플로우와 블로킹 호출을 섞어서 사용해서는 안 됩니다.</p><section class="chapter"><h3 id="api" data-toc="api">반응형 API의 이해</h3><p id="i74vva2_69">기본적으로 Spring WebFlux는 핵심 종속성으로 Reactor(https://projectreactor.io)를 사용합니다. Project Reactor는 Reactive Streams 라이브러리를 제공합니다. 이전 단락에서 언급한 대로, WebFlux는 입력을 Publisher로 받아들이고, 이를 Reactor 유형으로 적응시킨 후 Mono 또는 Flux 출력으로 반환합니다.</p><p id="i74vva2_70">Reactive Streams에서 Publisher가 수요에 따라 데이터를 Subscriber에게 전달한다는 건 알고 계시죠. 하나 또는 그 이상(무한히 많을 수도 있는)의 요소를 전달할 수 있습니다. Project Reactor는 이를 더 나아가 <span id="i74vva2_71"><b><font style="color:#ff7f50">Mono</font></b></span>와 <span id="i74vva2_72"><b><font style="color:#ff7f50">Flux</font></b></span> 두 가지 Publisher 구현체를 제공합니다. <span id="i74vva2_73"><b><font style="color:#ff7f50">Mono</font></b></span>는 구독자에게 0 또는 1을 반환할 수 있고, <span id="i74vva2_74"><b><font style="color:#ff7f50">Flux</font></b></span>는 0부터 N개의 요소를 반환합니다. 둘 다 <span id="i74vva2_75"><b><font style="color:#ff7f50">CorePublisher</font></b></span> 인터페이스를 구현한 추상 클래스입니다. CorePublisher 인터페이스는 publisher를 확장합니다.</p><p id="i74vva2_76">보통 Repository 사용법은 다음과 같습니다.</p><div class="code-block" data-lang="java">
public Product findById(UUID id);
public List&lt;Product&gt; getAll();
</div><p id="i74vva2_78">WebFlux에서는 Mono와 Flux로 대체됩니다.</p><div class="code-block" data-lang="java">
public Mono&lt;Product&gt; findById(UUID id);
public Flux&lt;Product&gt; getAll();
</div><p id="i74vva2_80">스트림은 소스를 다시 시작할 수 있는지 여부에 따라 핫인지 콜드인지가 결정됩니다. <span class="control" id="i74vva2_81">콜드 스트림</span>의 경우 여러 구독자가 있으면 각각에게 소스가 처음부터 다시 시작합니다. <span class="control" id="i74vva2_82">핫 스트림</span>의 경우 동일한 소스가 여러 구독자에게 사용됩니다.</p></section></section><div class="last-modified">Last modified: 20 6월 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="chapter04.html" class="navigation-links__prev">Chapter 4 - 비즈니스 로직 구현</a><a href="chapter06.html" class="navigation-links__next">Chapter 6 -인증 및 권한 부여를 사용하여 REST 엔드포인트 보호하기</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b267/app.js"></script></body></html>